МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
Кафедра «Програмна інженерія»
 
 


ЗВІТ
до лабораторної роботи 5
з дисципліни «Аналіз та рефакторинг коду»


 




Виконав:                                                           	 Перевірив:
ст. гр. ПЗПІ-23-3                                     	       	          ст. викладач катедри ПІ
Першина М. А.                                     	       	         Сокорчук Ігор Петрович






Харків 2025


1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	15.12.2025	0.1	Початок роботи серверною частиною програми
2	17.12.2025	0.2	Доопрацювання звіту та відеозапису




2 ЗАВДАННЯ
Навчитися розгортати програмну систему, перевіряти її функціональність, виконувати налаштування, а також демонструвати та документувати роботу системи.


3. ОПИС ІНЖЕНЕРНИХ РІШЕНЬ
3.1 Детальний опис розгортання системи
•	Архітектура розгортання
Система догляду за рослинами розгорнута за допомогою контейнеризованої архітектури на базі Docker, що складається з двох основних компонентів: серверної частини (Node.js API) та бази даних (PostgreSQL). Розгортання реалізовано через Docker Compose, який забезпечує оркестрацію багатоконтейнерного додатку з автоматичним управлінням залежностями.
•	Конфігурація середовища розгортання
Контейнеризація реалізована через наступні компоненти:
1.	Backend контейнер: 
o	Базовий образ: node:18-alpine - мінімалістичний Linux дистрибутив з попередньо встановленим Node.js версії 18
o	Робоче середовище: Ubuntu-подібна система з оптимізованим розміром для production
o	Процес збірки включає етапи: копіювання залежностей, встановлення пакетів, компіляцію TypeScript у JavaScript, очистку dev-залежностей
2.	Database контейнер: 
o	Образ PostgreSQL 15 на Alpine Linux для забезпечення стабільності та безпеки
o	Автоматична ініціалізація через SQL скрипти в директорії /docker-entrypoint-initdb.d
o	Persistent volume для збереження даних між перезапусками

•	Налаштування мережевої взаємодії
Створена ізольована Docker мережа plant_care_network типу bridge, яка забезпечує:
•	Внутрішню комунікацію між контейнерами за іменами сервісів
•	Ізоляцію від зовнішніх мереж для підвищення безпеки
•	DNS резолюцію між сервісами (backend може звертатися до postgres за ім'ям)

•	Конфігурація портів та доступу
•	PostgreSQL: внутрішній порт 5432, зовнішній доступ через localhost:5432
•	Backend API: внутрішній порт 3000, проксований на localhost:3000
•	Налаштовано healthcheck для моніторингу стану сервісів

3.2 Пояснення вибору технологій для розгортання
1. Вибір контейнеризації (Docker)
Docker обрано як основну технологію розгортання з наступних причин:
•	Портативність: додаток працює однаково на різних операційних системах
•	Ізоляція: кожен компонент працює в ізольованому середовищі без конфліктів
•	Скалованість: легке масштабування горизонтально та вертикально
•	Версіонування: можливість швидкого rollback до попередніх версій
•	Consistency: однакове середовище для development, testing та production
2. Вибір серверної платформи (Node.js 18)
Node.js вибрано для серверної частини через:
•	Асинхронність: ефективна робота з IoT датчиками та багатьма одночасними запитами
•	Ecosystem: багатий набір npm пакетів для роботи з базами даних та API
•	TypeScript підтримка: строга типізація для зменшення помилок у production
•	JSON native: природна робота з JSON даними від IoT пристроїв
•	Alpine Linux: мінімальний розмір образу (близько 100MB проти 1GB+ для повного Linux)
3. Вибір системи управління базами даних (PostgreSQL 15)
PostgreSQL обрано як основну СУБД з таких міркувань:
•	Реляційна модель: чітка структура даних для користувачів, рослин та датчиків
•	ACID транзакції: надійність при записі критичних IoT даних
•	JSON підтримка: нативна робота з JSON даними від датчиків без втрати реляційних переваг
•	Масштабованість: ефективна робота з великими обсягами sensor data
•	Безпека: вбудовані механізми автентифікації та авторизації
•	Alpine образ: оптимізований розмір для контейнеризації
4. Мережеві протоколи та конфігурації
•	HTTP/HTTPS: стандартний протокол для REST API з можливістю додавання SSL/TLS
•	Bridge мережа Docker: забезпечує ізольовану комунікацію між контейнерами
•	Environment variables: безпечне управління конфігураціями без hardcode значень
•	Health checks: автоматичний моніторинг стану сервісів через HTTP endpoints
5. Оркестрація через Docker Compose
Docker Compose вибрано для управління багатоконтейнерним додатком:
•	Декларативна конфігурація: опис всієї інфраструктури в одному YAML файлі
•	Автоматичне управління залежностями: backend чекає готовності database
•	Persistent storage: автоматичне управління volumes для збереження даних
•	Одна команда розгортання: простий docker-compose up запускає всю систему

4. ФРАГМЕНТИ ПРОГРАМНОГО КОДУ

4.1 Логіка бізнес процесів серверної частини.
•	Автентифікація та авторизація
Система використовує JWT токени для безпечної автентифікації користувачів. Реалізовано ролеву модель доступу з розділенням прав між звичайними користувачами та адміністраторами.
•	Реєстрація нового користувача
Запит:
POST /api/auth/register
{
  "email": "demo@example.com",
  "first_name": "Demo",
  "last_name": "User",
  "password": "123456"
}
Відповідь:
{
  "success": true,
  "data": {
    "user": {
      "user_id": 1,
      "email": "demo@example.com",
      "first_name": "Demo",
      "last_name": "User",
      "role": "user",
      "created_at": "2025-12-14T13:42:45.747Z"
    }
  },
  "message": "User registered successfully. Please login to get access token."
}
•	Вхід в систему
Запит:
POST /api/auth/login
{
  "email": "demo@example.com", 
  "password": "123456"
}
Відповідь:
{
  "success": true,
  "data": {
    "user": {
      "user_id": 1,
      "email": "demo@example.com",
      "first_name": "Demo",
      "last_name": "User",
      "role": "user",
      "last_login": "2025-12-14T16:30:15.123Z"
    },
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  },
  "message": "Login successful"
}

•	 Управління типами рослин
Система підтримує різні типи рослин з їх оптимальними параметрами для вирощування. Кожен тип має встановлені значення вологості, температури, освітленості та частоти поливу.
Запит:
GET /api/plant-types
Відповідь:
{
  "success": true,
  "data": [
    {
      "plant_type_id": 1,
      "name": "Фіалка кімнатна",
      "optimal_humidity": 65.0,
      "optimal_temperature": 20.0,
      "optimal_light": 15000,
      "watering_frequency": 3
    }
  ]
}



•	 CRUD операції для рослин користувача
Користувачі можуть створювати, переглядати, редагувати та видаляти свої рослини. Система забезпечує ізоляцію даних - користувач має доступ тільки до власних рослин.
•	Створення рослини
Запит:
POST /api/my-plants
Authorization: Bearer {JWT_TOKEN}
{
  "plant_type_id": 1,
  "name": "Моя фіалка",
  "location": "Підвіконня"
}
Відповідь:
{
  "success": true,
  "data": {
    "plant_id": 5,
    "user_id": 1,
    "plant_type_id": 1,
    "name": "Моя фіалка",
    "location": "Підвіконня",
    "plantType": {
      "plant_type_id": 1,
      "name": "Фіалка кімнатна",
      "optimal_humidity": 65.0,
      "optimal_temperature": 20.0,
      "optimal_light": 15000,
      "watering_frequency": 3
    },
    "created_at": "2025-12-14T16:45:12.456Z"
  },
  "message": "Plant created successfully"
}

•	Перегляд власних рослин
Запит:
GET /api/my-plants
Authorization: Bearer {JWT_TOKEN}
Відповідь:
{
  "success": true,
  "data": [
    {
      "plant_id": 5,
      "name": "Моя фіалка",
      "location": "Підвіконня",
      "plantType": {
        "name": "Фіалка кімнатна",
        "optimal_humidity": 65.0,
        "optimal_temperature": 20.0
      },
      "created_at": "2025-12-14T16:45:12.456Z"
    }
  ],
  "message": "Your plants retrieved successfully"
}

•	Інтелектуальний аналіз даних IoT датчиків
Найголовніша інноваційна функція системи - автоматичний аналіз даних з IoT датчиків з генерацією конкретних команд для виконавчих пристроїв. Система порівнює поточні показники з оптимальними значеннями для кожного типу рослини та створює персоналізовані рекомендації.
Запит:
POST /api/sensors/analyze
{
  "hardware_ids": [
    "HUM_001_A1B2", 
    "TEMP_001_C3D4", 
    "LIGHT_001_E5F6",
    "HUM_002_G7H8"
  ]
}
Відповідь наведено у додатку Б.

3.6 Інші реалізовані функції
Система також включає наступні додаткові ендпоінти:
•	Редагування рослин (PUT /api/my-plants/{id}) - оновлення назви та локації рослин
•	Видалення рослин (DELETE /api/my-plants/{id}) - видалення власних рослин
•	Створення типів рослин (POST /api/plant-types) - адміністративна функція
•	Перегляд всіх рослин (GET /api/plants) - адміністративний доступ
•	Вихід з системи (POST /api/auth/logout) - завершення сесії
•	Отримання профілю (GET /api/auth/me) - інформація про поточного користувача

4.2 Логіка адміністрування серверної частини.
Адміністратори мають розширені права доступу до всіх даних системи, включаючи перегляд всіх користувачів, рослин, датчиків та даних з датчиків.
•	Перегляд всіх користувачів
Запит:
GET /api/users
Authorization: Bearer {ADMIN_JWT_TOKEN}
Відповідь:
{
  "success": true,
  "data": [
    {
      "user_id": 1,
      "email": "admin@plantcare.com",
      "first_name": "Admin",
      "last_name": "System",
      "role": "admin",
      "last_login": "2025-12-14T15:30:22.789Z"
    }
  ],
  "message": "Users retrieved successfully"
}


•	Створення нового користувача
Запит:
POST /api/users
Authorization: Bearer {ADMIN_JWT_TOKEN}
Content-Type: application/json
{
  "email": "newuser@example.com",
  "first_name": "New",
  "last_name": "User",
  "password": "password123"
}
Відповідь:
{
  "success": true,
  "data": {
    "user_id": 2,
    "email": "newuser@example.com",
    "first_name": "New",
    "last_name": "User",
    "role": "user",
    "created_at": "2025-12-23T18:30:00.000Z"
  },
  "message": "User created successfully"
}

•	Перегляд всіх рослин (адміністративний доступ)
Запит:
GET /api/plants
Authorization: Bearer {ADMIN_JWT_TOKEN}
Відповідь:
{
  "success": true,
  "data": [
    {
      "plant_id": 1,
      "name": "Фіалка офісна",
      "location": "Кімната 201",
      "user": {
        "user_id": 1,
        "first_name": "Іван",
        "last_name": "Петренко",
        "email": "ivan@example.com"
      },
      "plantType": {
        "name": "Фіалка",
        "optimal_humidity": 60.0,
        "optimal_temperature": 22.0
      }
    }
  ],
  "message": "Plants retrieved successfully"
}

•	Перегляд всіх датчиків
Запит:
GET /api/sensors
Authorization: Bearer {ADMIN_JWT_TOKEN}
Відповідь:
{
  "success": true,
  "data": [
    {
      "sensor_id": 1,
      "plant_id": 1,
      "sensor_type": "humidity",
      "hardware_id": "HUM_001_A1B2",
      "is_active": true,
      "plant": {
        "plant_id": 1,
        "name": "Моя улюблена фіалка",
        "location": "Підвіконня кухні"
      }
    }
  ],
  "message": "Sensors retrieved successfully"
}

•	Створення нового датчика
Запит:
POST /api/sensors
Authorization: Bearer {ADMIN_JWT_TOKEN}
Content-Type: application/json

{
  "plant_id": 1,
  "sensor_type": "temperature",
  "hardware_id": "TEMP_002_X3Y4",
  "is_active": true
}
Відповідь:
{
  "success": true,
  "data": {
    "sensor_id": 2,
    "plant_id": 1,
    "sensor_type": "temperature",
    "hardware_id": "TEMP_002_X3Y4",
    "is_active": true,
    "plant": {
      "plant_id": 1,
      "name": "Моя улюблена фіалка",
      "location": "Підвіконня кухні"
    }
  },
  "message": "Sensor created successfully"
}

•	Перегляд всіх даних датчиків
Запит:
GET /api/sensor-data?limit=50&offset=0
Authorization: Bearer {ADMIN_JWT_TOKEN}
Відповідь:
{
  "success": true,
  "data": [
    {
      "data_id": 1,
      "sensor_id": 1,
      "value": 65.5,
      "timestamp": "2025-12-23T18:25:00.000Z",
      "sensor": {
        "sensor_id": 1,
        "sensor_type": "humidity",
        "hardware_id": "HUM_001_A1B2",
        "plant": {
          "plant_id": 1,
          "name": "Моя улюблена фіалка",
          "location": "Підвіконня кухні"
        }
      }
    }
  ],
  "message": "Sensor data retrieved successfully"
}

•	Видалення користувача
Запит:
DELETE /api/users/{id}
Authorization: Bearer {ADMIN_JWT_TOKEN}
Відповідь:
{
  "success": true,
  "message": "User deleted successfully"
}

•	Оновлення інформації користувача
Запит:
PUT /api/users/{id}
Authorization: Bearer {ADMIN_JWT_TOKEN}
Content-Type: application/json
{
  "first_name": "Оновлене ім'я",
  "last_name": "Оновлене прізвище"
}
Відповідь:
{
  "success": true,
  "data": {
    "user_id": 1,
    "email": "user@example.com",
    "first_name": "Оновлене ім'я",
    "last_name": "Оновлене прізвище",
    "role": "user"
  },
  "message": "User updated successfully"
}

4.3 Логіка налаштування IoT клієнта та взаємодії з сервером.
Код бізнес логіки - обробка та передача даних
Функція performMonitoringCycle реалізує основний алгоритм роботи IoT системи за принципом "збір → передача → аналіз → дія". Використовується послідовна обробка з обов'язковою перевіркою кожного етапу - якщо збій на будь-якому кроці, система переходить в режим помилки і припиняє поточний цикл. Це забезпечує надійність роботи та попереджає виконання помилкових команд на основі неякісних даних.
void performMonitoringCycle() {
  Serial.println("\n Monitoring...");
  setLEDStatus("reading");
  
  SensorReading reading = readAllSensors();
  
  if (!reading.isValid) {
    Serial.println("Sensor reading failed");
    setLEDStatus("error");
    return;
  }
  setLEDStatus("transmitting");
  if (!sendSensorDataToServer(reading)) {
    Serial.println("Failed to send data");
    setLEDStatus("error");
    return;
  }
  if (requestAnalysisFromServer()) {
    setLEDStatus("ready");
  } else {
    setLEDStatus("error");
  }
Функція інкапсулює всю логіку збору та первинної обробки сенсорних даних. Використовується структурований підхід з нормалізацією аналогових сигналів через функцію map() для приведення сирих значень АЦП до фізичних величин (люкси, відсотки). Критично важливою є валідація даних з DHT22, оскільки цей датчик може повертати NaN при збоях, що призведе до некоректної роботи всієї системи. Структура SensorReading забезпечує типізовану передачу даних між модулями.
SensorReading readAllSensors() {
  SensorReading reading;
  reading.isValid = true;
  
  reading.airHumidity = dht.readHumidity();
  reading.airTemperature = dht.readTemperature();
  
  int rawLight = analogRead(LDR_PIN);
  reading.lightLevel = map(rawLight, 0, 4095, 0, 25000);
  
  int rawSoil = analogRead(SOIL_MOISTURE_PIN);
  reading.soilMoisture = map(rawSoil, 0, 4095, 0, 100);
  
  if (isnan(reading.airHumidity) || isnan(reading.airTemperature)) {
    reading.isValid = false;
  }
  
  return reading;
}

Код взаємодії з серверною частиною
Функція реалізує клієнт-серверну взаємодію за RESTful принципами з використанням HTTP POST запитів. JSON структура даних відповідає API специфікації бекенду, де кожен датчик ідентифікується унікальним sensor_id для правильної маршрутизації в базі даних. Перевірка стану WiFi на початку функції запобігає блокуванню системи при відсутності мережі. Таймаут у 10 секунд балансує між надійністю доставки та швидкістю реакції системи на мережеві проблеми.
bool sendSensorDataToServer(SensorReading &reading) {
  if (WiFi.status() != WL_CONNECTED) {
    return false;
  }
  
  HTTPClient http;
  http.begin(sendDataURL);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(10000);
  
  StaticJsonDocument<1024> doc;
  JsonArray data = doc.createNestedArray("data");
  
  if (!isnan(reading.airHumidity)) {
    JsonObject humid = data.createNestedObject();
    humid["sensor_id"] = HUMIDITY_SENSOR_ID;
    humid["value"] = reading.airHumidity;
  }
  
  String jsonString;
  serializeJson(doc, jsonString);
  int httpResponseCode = http.POST(jsonString);
  bool success = (httpResponseCode == 200 || httpResponseCode == 201);
  http.end();
  return success;
}
Ця функція забезпечує інтеграцію з системою бекенду через передачу масиву hardware_ids для ідентифікації конкретних датчиків у системі. Збільшений таймаут до 15 секунд враховує складність аналітичних обчислень на сервері. Архітектура дозволяє бекенду аналізувати дані з множинних IoT пристроїв одночасно, а клієнт отримує персоналізовані команди саме для своїх датчиків, що забезпечує масштабованість системи.
bool requestAnalysisFromServer() {
  HTTPClient http;
  http.begin(analyzeURL);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(15000);
  
  StaticJsonDocument<512> requestDoc;
  JsonArray hardwareIds = requestDoc.createNestedArray("hardware_ids");
  hardwareIds.add(HUMIDITY_HW_ID);
  hardwareIds.add(TEMP_AIR_HW_ID);
  hardwareIds.add(LIGHT_HW_ID);
  hardwareIds.add(SOIL_MOISTURE_HW_ID);
  hardwareIds.add(TEMP_SOIL_HW_ID);
  
  String requestJson;
  serializeJson(requestDoc, requestJson);
  
  int httpResponseCode = http.POST(requestJson);
  String response = http.getString();
  
  if (httpResponseCode == 200 || httpResponseCode == 201) {
    parseAndExecuteCommands(response);
    http.end();
    return true;
  }
  
  http.end();
  return false;
}

Код функцій налаштування та конфігурування
Функція setup() виконується один раз при запуску і реалізує критичний етап ініціалізації всіх компонентів системи. Послідовність ініціалізації важлива - спочатку налаштовуються апаратні компоненти (датчики, сервопривід), потім GPIO піни, і тільки після цього встановлюється мережеве з'єднання. Затримка 2 секунди на початку дає час ESP32 стабілізуватися після перезавантаження. Початкова позиція сервоприводу (0 градусів) гарантує, що система почне роботу в безпечному стані без випадкового поливу.
void setup() {
  Serial.begin(115200);
  delay(2000);
  
  Serial.println("PlantCare IoT Client");
  dht.begin();
  wateringServo.attach(SERVO_PIN);
  pinMode(LDR_PIN, INPUT);
  pinMode(SOIL_MOISTURE_PIN, INPUT);
  pinMode(LED_RED_PIN, OUTPUT);
  pinMode(LED_GREEN_PIN, OUTPUT);
  pinMode(LED_BLUE_PIN, OUTPUT);
  wateringServo.write(0);
  setLEDStatus("connecting");
  
  connectToWiFi();
  Serial.println("System ready - monitoring violet");
  setLEDStatus("ready");
}
Функція реалізує підключення до WiFi мережі з обмеженням спроб підключення (30 спроб по 0.5 секунди = 15 секунд максимум). Це запобігає безкінечному очікуванню при недоступності мережі та дозволяє системі перейти в автономний режим роботи. Виведення IP адреси в консоль необхідне для діагностики мережевих проблем та можливості прямого доступу до пристрою через локальну мережу в майбутніх версиях.
void connectToWiFi() {
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected!");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi failed!");
    setLEDStatus("error");
  }
}


5. UML-ДІАГРАМИ
5.1 UML діаграма прецедентів для серверної частини системи
 
Рисунок 1 - UML діаграма прецедентів для серверної частини системи
UML діаграма прецедентів показує, що користувач може автентифікуватися та авторизуватися в системі (реєстрація, вхід), управляти рослинами (додавання, редагування, видалення), моніторити показники рослин (перегляд поточних даних та історії вимірювань), налаштовувати автоматизацію догляду (автоматичний полив, освітлення, планування), отримувати сповіщення про стан рослин (критичні алерти, оновлення статусу) та переглядати аналітику і звіти (щоденні звіти, аналіз трендів росту). IoT пристрій може надсилати дані з датчиків (що включає валідацію та збереження даних у БД) та виконувати команди догляду, які генеруються системою автоматизації. Діаграма демонструє, що всі процеси автоматичного догляду (полив, освітлення, планування) обов'язково включають обробку логіки автоматизації, яка визначає необхідні дії на основі отриманих даних з датчиків та налаштувань користувача.

5.2 Діаграма структури БД
 
Рисунок 2 - Діаграма структури БД

5.3 UML діаграма прецедентів для IoT клієнта
 
Рисунок 3 - UML діаграма прецедентів
Дана діаграма прецедентів ілюструює функціональну архітектуру IoT системи автоматичного догляду за рослинами з позиції взаємодії з користувачами та зовнішніми системами. Центральним прецедентом є "Моніторити стан рослини", який включає обов'язкові підпроцеси збору та валідації даних датчиків через зв'язки <<include>>, що гарантує цілісність інформації перед подальшою обробкою. Система взаємодіє з двома ключовими акторами: власник рослини отримує візуальну інформацію про стан системи, тоді як Backend AI система забезпечує інтелектуальний аналіз телеметрії та генерацію команд керування. Розширюючі прецеденти (<<extend>>) моделюють автономні функції реагування на критичні ситуації - автоматичний полив при засусі, додаткове освітлення при нестачі світла, та клімат-контроль при температурних відхиленнях. Така архітектура забезпечує гнучкість системи, де базовий моніторинг завжди активний, а спеціалізовані дії виконуються тільки за потреби, відповідно до аналізу бекенду.

5.4 UML діаграма діяльності для IoT клієнта
 
Рисунок 4 - UML діаграма діяльності
Ця діаграма діяльності демонструє циклічну архітектуру IoT клієнта, де система працює у безперервному режимі з фіксованими інтервалами у 30 секунд. Ключовою особливістю є відказостійкість - на кожному етапі передбачена обробка помилок з можливістю відновлення роботи. Діаграма показує асинхронну природу системи, де основний цикл моніторингу працює незалежно від виконання команд актуаторів. Рішення реалізовані через умовні переходи (ромби), що забезпечують різні сценарії роботи залежно від стану мережі, якості даних та наявності команд від бекенду. Паралельні процеси контролю таймаутів гарантують безпечну роботу актуаторів та автоматичне повернення до початкового стану після завершення дій. Така архітектура забезпечує автономність системи навіть при тимчасових збоях мережі чи окремих компонентів.


6. ВИСНОВКИ
У ході виконання лабораторної роботи №5 успішно розроблено та розгорнуто IoT частину системи догляду за рослинами з використанням Arduino C++ та симулятора Wokwi, яка забезпечує повний цикл автоматизованого моніторингу: збір даних з датчиків вологості, температури та освітленості, передачу інформації на backend через HTTP протокол з використанням bulk API endpoints, отримання команд розумного аналізу від серверної частини та виконання відповідних дій через виконавчі пристрої (полив, освітлення, вентиляція). Розгорнутий IoT застосунок демонструє практичну реалізацію концепцій Інтернету речей у сільськогосподарській галузі, забезпечуючи автоматизований догляд за рослинами з мінімальним втручанням користувача та готовий для масштабування у реальних умовах з фізичним Arduino обладнанням.
7. ВИКОРИСТАНІ ДЖЕРЕЛА
1.	Node.js Official Documentation [Електронний ресурс]. – Режим доступу: https://nodejs.org/en/docs/ – Дата доступу: 13.12.2025. 
2.	Express.js Framework Documentation [Електронний ресурс]. – Режим доступу: https://expressjs.com/ – Дата доступу: 13.12.2025. 
3.	Sequelize ORM Documentation [Електронний ресурс]. – Режим доступу: https://sequelize.org/docs/ – Дата доступу: 13.12.2025. 
4.	PostgreSQL Official Documentation [Електронний ресурс]. – Режим доступу: https://www.postgresql.org/docs/ – Дата доступу: 13.12.2025. 
5.	OpenAPI Specification 3.0 [Електронний ресурс]. – Режим доступу: https://swagger.io/specification/ – Дата доступу: 13.12.2025. 
6.	TypeScript Documentation [Електронний ресурс]. – Режим доступу: https://www.typescriptlang.org/docs/ – Дата доступу: 13.12.2025. 
7.	Docker Documentation [Електронний ресурс]. – Режим доступу: https://docs.docker.com/ – Дата доступу: 13.12.2025. 


ДОДАТОК А
Відеозапис

Відеозапис доповіді: https://youtu.be/gFx94D6Ge0k

Хронологічний опис відеозапису: 
00:00 - Вступ 
00:14 - Пояснення вибору технологій 
01:02 - Опис розгортання системи
04:53 - Перевірка роботи серверної частини з базою даних
05:33 - Перевірка роботи IoT частини