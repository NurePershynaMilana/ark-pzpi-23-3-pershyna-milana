МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
 
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
Кафедра «Програмна інженерія»
 
 


ЗВІТ
до лабораторної роботи 4
з дисципліни «Аналіз та рефакторинг коду»


 




Виконав:                                                           	  Перевірив:
ст. гр. ПЗПІ-23-3                                     	       	          ст. викладач катедри ПІ
Першина М. А.                                     	       	         Сокорчук Ігор Петрович






Харків 2025


1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	11.12.2025	0.1	Початок роботи серверною частиною програми
2	15.12.2025	0.2	Доопрацювання звіту та відеозапису



2 ЗАВДАННЯ
Отримати практичні навички з розробки IoT клієнта, включаючи проектування його архітектури, бізнес логіки, налаштувань, та інтеграцію із серверною частиною. Навчитися використовувати UML для створення діаграм прецедентів та діяльності, а також перевіряти функціональність IoT клієнта через тестування та інтеграцію.

3. ОПИС ІНЖЕНЕРНИХ РІШЕНЬ
3.1 Архітектурні рішення IoT клієнта
IoT клієнт побудований на основі мікроконтролера ESP32 з модульною архітектурою, що забезпечує гнучкість та можливість масштабування:
Компонентна архітектура:
•	Сенсорний рівень - збір даних з множинних датчиків (DHT22, фоторезистор, потенціометр)
•	Логічний рівень - обробка даних, валідація та підготовка до передачі
•	Комунікаційний рівень - взаємодія з хмарним бэкендом через HTTP/HTTPS
•	Виконавчий рівень - управління актуаторами (сервопривід, LED освітлення)
 
Рисунок 1 – зовнішній вигляд IoT частини системи
Принципи проектування:
•	Автономність - система працює незалежно з мінімальним втручанням користувача
•	Відказостійкість - обробка мережевих збоїв та помилок датчиків
•	Енергоефективність - оптимізовані інтервали опитування (30 секунд)
•	Модульність - легке додавання нових датчиків та актуаторів

3.2 Вибір методів комунікації та протоколів
Мережевий протокол: HTTP/HTTPS над WiFi
ESP32 WiFi → Internet → HTTPS Backend API
Обґрунтування вибору:
•	HTTP REST API - стандартизований підхід для IoT систем
•	JSON формат - легкість парсингу та читабельність
•	HTTPS - забезпечення безпеки передачі даних
•	WiFi - стабільне підключення в домашніх умовах

Альтернативи та їх недоліки:
•	MQTT: складніша реалізація, потребує брокера
•	CoAP: менша підтримка в екосистемі
•	LoRaWAN: обмежена пропускна здатність

3.3 Бізнес логіка IoT клієнта
Цикл роботи системи:
1.	Моніторинг (30 сек) → Аналіз → Дії → Повторення
2.	Збір даних з 5 датчиків одночасно
3.	Валідація показників на коректність
4.	Передача в JSON форматі на бэкенд
5.	Отримання команд від системи штучного інтелекту
6.	Виконання автоматичних дій (полив, освітлення)



4. ФРАГМЕНТИ ПРОГРАМНОГО КОДУ
4.1 Код бізнес логіки - обробка та передача даних
Функція performMonitoringCycle реалізує основний алгоритм роботи IoT системи за принципом "збір → передача → аналіз → дія". Використовується послідовна обробка з обов'язковою перевіркою кожного етапу - якщо збій на будь-якому кроці, система переходить в режим помилки і припиняє поточний цикл. Це забезпечує надійність роботи та попереджає виконання помилкових команд на основі неякісних даних.
void performMonitoringCycle() {
  Serial.println("\n Monitoring...");
  setLEDStatus("reading");
  
  SensorReading reading = readAllSensors();
  
  if (!reading.isValid) {
    Serial.println("Sensor reading failed");
    setLEDStatus("error");
    return;
  }
  setLEDStatus("transmitting");
  if (!sendSensorDataToServer(reading)) {
    Serial.println("Failed to send data");
    setLEDStatus("error");
    return;
  }
  if (requestAnalysisFromServer()) {
    setLEDStatus("ready");
  } else {
    setLEDStatus("error");
  }
Функція інкапсулює всю логіку збору та первинної обробки сенсорних даних. Використовується структурований підхід з нормалізацією аналогових сигналів через функцію map() для приведення сирих значень АЦП до фізичних величин (люкси, відсотки). Критично важливою є валідація даних з DHT22, оскільки цей датчик може повертати NaN при збоях, що призведе до некоректної роботи всієї системи. Структура SensorReading забезпечує типізовану передачу даних між модулями.
SensorReading readAllSensors() {
  SensorReading reading;
  reading.isValid = true;
  
  reading.airHumidity = dht.readHumidity();
  reading.airTemperature = dht.readTemperature();
  
  int rawLight = analogRead(LDR_PIN);
  reading.lightLevel = map(rawLight, 0, 4095, 0, 25000);
  
  int rawSoil = analogRead(SOIL_MOISTURE_PIN);
  reading.soilMoisture = map(rawSoil, 0, 4095, 0, 100);
  
  if (isnan(reading.airHumidity) || isnan(reading.airTemperature)) {
    reading.isValid = false;
  }
  
  return reading;
}

4.2 Код взаємодії з серверною частиною
Функція реалізує клієнт-серверну взаємодію за RESTful принципами з використанням HTTP POST запитів. JSON структура даних відповідає API специфікації бекенду, де кожен датчик ідентифікується унікальним sensor_id для правильної маршрутизації в базі даних. Перевірка стану WiFi на початку функції запобігає блокуванню системи при відсутності мережі. Таймаут у 10 секунд балансує між надійністю доставки та швидкістю реакції системи на мережеві проблеми.
bool sendSensorDataToServer(SensorReading &reading) {
  if (WiFi.status() != WL_CONNECTED) {
    return false;
  }
  
  HTTPClient http;
  http.begin(sendDataURL);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(10000);
  
  StaticJsonDocument<1024> doc;
  JsonArray data = doc.createNestedArray("data");
  
  if (!isnan(reading.airHumidity)) {
    JsonObject humid = data.createNestedObject();
    humid["sensor_id"] = HUMIDITY_SENSOR_ID;
    humid["value"] = reading.airHumidity;
  }
  
  String jsonString;
  serializeJson(doc, jsonString);
  int httpResponseCode = http.POST(jsonString);
  bool success = (httpResponseCode == 200 || httpResponseCode == 201);
  http.end();
  return success;
}
Ця функція забезпечує інтеграцію з системою штучного інтелекту бекенду через передачу масиву hardware_ids для ідентифікації конкретних датчиків у системі. Збільшений таймаут до 15 секунд враховує складність аналітичних обчислень на сервері. Архітектура дозволяє бекенду аналізувати дані з множинних IoT пристроїв одночасно, а клієнт отримує персоналізовані команди саме для своїх датчиків, що забезпечує масштабованість системи.
bool requestAnalysisFromServer() {
  HTTPClient http;
  http.begin(analyzeURL);
  http.addHeader("Content-Type", "application/json");
  http.setTimeout(15000);
  
  StaticJsonDocument<512> requestDoc;
  JsonArray hardwareIds = requestDoc.createNestedArray("hardware_ids");
  hardwareIds.add(HUMIDITY_HW_ID);
  hardwareIds.add(TEMP_AIR_HW_ID);
  hardwareIds.add(LIGHT_HW_ID);
  hardwareIds.add(SOIL_MOISTURE_HW_ID);
  hardwareIds.add(TEMP_SOIL_HW_ID);
  
  String requestJson;
  serializeJson(requestDoc, requestJson);
  
  int httpResponseCode = http.POST(requestJson);
  String response = http.getString();
  
  if (httpResponseCode == 200 || httpResponseCode == 201) {
    parseAndExecuteCommands(response);
    http.end();
    return true;
  }
  
  http.end();
  return false;
}
4.3 Код функцій налаштування та конфігурування
Функція setup() виконується один раз при запуску і реалізує критичний етап ініціалізації всіх компонентів системи. Послідовність ініціалізації важлива - спочатку налаштовуються апаратні компоненти (датчики, сервопривід), потім GPIO піни, і тільки після цього встановлюється мережеве з'єднання. Затримка 2 секунди на початку дає час ESP32 стабілізуватися після перезавантаження. Початкова позиція сервоприводу (0 градусів) гарантує, що система почне роботу в безпечному стані без випадкового поливу.
void setup() {
  Serial.begin(115200);
  delay(2000);
  
  Serial.println("PlantCare IoT Client");
  dht.begin();
  wateringServo.attach(SERVO_PIN);
  pinMode(LDR_PIN, INPUT);
  pinMode(SOIL_MOISTURE_PIN, INPUT);
  pinMode(LED_RED_PIN, OUTPUT);
  pinMode(LED_GREEN_PIN, OUTPUT);
  pinMode(LED_BLUE_PIN, OUTPUT);
  wateringServo.write(0);
  setLEDStatus("connecting");
  
  connectToWiFi();
  Serial.println("System ready - monitoring violet");
  setLEDStatus("ready");
}
Функція реалізує робастне підключення до WiFi мережі з обмеженням спроб підключення (30 спроб по 0.5 секунди = 15 секунд максимум). Це запобігає безкінечному очікуванню при недоступності мережі та дозволяє системі перейти в автономний режим роботи. Виведення IP адреси в консоль необхідне для діагностики мережевих проблем та можливості прямого доступу до пристрою через локальну мережу в майбутніх версиях.
void connectToWiFi() {
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected!");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi failed!");
    setLEDStatus("error");
  }
}
Функція реалізує інтуїтивну візуальну діагностику стану системи через RGB LED індикацію. Кольорове кодування відповідає загальноприйнятим стандартам (зелений = готовність, червоний = помилка, жовтий = процес). Обов'язкове вимкнення всіх LED на початку функції запобігає змішуванню кольорів при швидкій зміні станів. Ця система критично важлива для віддаленого моніторингу стану IoT пристрою без доступу до консольних повідомлень.
void setLEDStatus(String status) {
  digitalWrite(LED_RED_PIN, LOW);
  digitalWrite(LED_GREEN_PIN, LOW);
  digitalWrite(LED_BLUE_PIN, LOW);
  
  if (status == "connecting") {
    digitalWrite(LED_RED_PIN, HIGH);
    digitalWrite(LED_GREEN_PIN, HIGH);
  }
  else if (status == "ready") {
    digitalWrite(LED_GREEN_PIN, HIGH);
  }
  // ... інші статуси
}


5. UML-ДІАГРАМИ
5.1 UML діаграма прецедентів для IoT клієнта
 
Рисунок 2 - UML діаграма прецедентів
Дана діаграма прецедентів ілюструює функціональну архітектуру IoT системи автоматичного догляду за рослинами з позиції взаємодії з користувачами та зовнішніми системами. Центральним прецедентом є "Моніторити стан рослини", який включає обов'язкові підпроцеси збору та валідації даних датчиків через зв'язки <<include>>, що гарантує цілісність інформації перед подальшою обробкою. Система взаємодіє з двома ключовими акторами: власник рослини отримує візуальну інформацію про стан системи, тоді як Backend AI система забезпечує інтелектуальний аналіз телеметрії та генерацію команд керування. Розширюючі прецеденти (<<extend>>) моделюють автономні функції реагування на критичні ситуації - автоматичний полив при засусі, додаткове освітлення при нестачі світла, та клімат-контроль при температурних відхиленнях. Така архітектура забезпечує гнучкість системи, де базовий моніторинг завжди активний, а спеціалізовані дії виконуються тільки за потреби, відповідно до аналізу штучного інтелекту бекенду.
 
Рисунок 3 - UML діаграма діяльності
Ця діаграма діяльності демонструє циклічну архітектуру IoT клієнта, де система працює у безперервному режимі з фіксованими інтервалами у 30 секунд. Ключовою особливістю є відказостійкість - на кожному етапі передбачена обробка помилок з можливістю відновлення роботи. Діаграма показує асинхронну природу системи, де основний цикл моніторингу працює незалежно від виконання команд актуаторів. Рішення реалізовані через умовні переходи (ромби), що забезпечують різні сценарії роботи залежно від стану мережі, якості даних та наявності команд від бекенду. Паралельні процеси контролю таймаутів гарантують безпечну роботу актуаторів та автоматичне повернення до початкового стану після завершення дій. Така архітектура забезпечує автономність системи навіть при тимчасових збоях мережі чи окремих компонентів.
6. ВИСНОВКИ
У ході виконання лабораторної роботи №4 успішно розроблено IoT частину системи догляду за рослинами з використанням Ardruino C++ та сайту Wokwi. Реалізовано передання даних з датчиків на бекенд для їх подальшої обробки та також реалізовано виконання вказівок – результатів аналізу, IoT частиною системи.
7. ВИКОРИСТАНІ ДЖЕРЕЛА
1.	Node.js Official Documentation [Електронний ресурс]. – Режим доступу: https://nodejs.org/en/docs/ – Дата доступу: 13.12.2025. 
2.	Express.js Framework Documentation [Електронний ресурс]. – Режим доступу: https://expressjs.com/ – Дата доступу: 13.12.2025. 
3.	TypeScript Documentation [Електронний ресурс]. – Режим доступу: https://www.typescriptlang.org/docs/ – Дата доступу: 13.12.2025. 
4.	Docker Documentation [Електронний ресурс]. – Режим доступу: https://docs.docker.com/ – Дата доступу: 13.12.2025. 


ДОДАТОК А
Відеозапис

Відеозапис доповіді: https://youtu.be/XAa7xPF6aKs

Хронологічний опис відеозапису: 
00:00 - Вступ 
00:23 - Пояснення призначення датчиків 
01:44 - Ввімкнення освітлення 
02:17 - Виконання поливу рослини 
02:44 - Ввімкнення охолодження 
03:06 - Ввімкнення обігрівача