
Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії

Звіт
до практичного завдання № 1
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду в JavaScript згідно зі стандартом Google JavaScript Style Guide: іменування, структура коду, стильові рекомендації в React проєктах»

Виконала:                                                                Перевірив:
ст. гр. ПЗПІ-23-3						ст. викладач катедри ПІ
Першина Мілана                					Сокорчук Ігор Петрович







Харків - 2025
1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
01.11.2025
0.1
Початок роботи над презентацією і доповіддю
2
06.11.2025
0.2
Доопрацювання звіту та відеозапису


2 ЗАВДАННЯ 
Правила оформлення програмного коду в JavaScript згідно зі стандартом Google JavaScript Style Guide: іменування, структура коду, стильові рекомендації в React проєктах

3 ОПИС ВИКОНАНОЇ РОБОТИ 
У сучасній розробці програмного забезпечення стандартизація стилю коду набуває особливого значення, адже забезпечує ефективну комунікацію між членами команди, знижує ймовірність виникнення помилок та полегшує процес інтеграції нових учасників у проєкт.
Впровадження стандарту Google JavaScript Style Guide у React проєктах дозволяє досягти високого рівня якості коду завдяки чітким конвенціям іменування, структурування файлів та форматування. Цей підхід базується на принципах консистентності, максимальної виразності коду та дотримання найкращих практик індустрії розробки.
Перший критичний аспект стандарту стосується системи найменування ідентифікаторів. Змінні та методи оформлюються у форматі camelCase, що забезпечує природну читабельність англомовних назв. Глобальні константи записуються через UPPER_SNAKE_CASE для візуального виділення незмінних значень. React компоненти, класи та конструктори отримують імена у форматі PascalCase, що одразу сигналізує про їх природу.
Особливу увагу приділено найменуванню функцій у контексті React розробки. Всі функції повинні починатися з дієслів, що відображають їх призначення. Обробники подій отримують обов'язковий префікс "handle", наприклад handleEmailChange або handleSubmit. Це створює передбачувану структуру коду, де призначення кожної функції зрозуміле без додаткового аналізу.
Архітектура файлів та модульна організація складають другий фундаментальний блок стандарту. Імпорти групуються за чотирма категоріями у суворій послідовності: зовнішні npm бібліотеки, внутрішні React компоненти, утилітарні функції та константи, стильові файли. Така ієрархія забезпечує швидку орієнтацію у залежностях модуля.
Внутрішня структура React компонентів також регламентована: хуки управління станом розміщуються першими, далі йдуть хуки побічних ефектів, потім визначаються обробники подій, допоміжні функції обчислення, і завершується все JSX розміткою. Ця послідовність відповідає життєвому циклу компонента та природному ходу читання коду.
Технічні аспекти форматування включають використання двох пробілів для створення рівнів вкладеності. Обов'язкове застосування крапки з комою запобігає проблемам автоматичної вставки, які можуть призвести до логічних помилок. Обмеження довжини рядка у 80 символів підтримує читабельність на різних пристроях та при розділеному екрані. Порожні рядки стратегічно розміщуються між логічними блоками для створення візуальної структури та полегшення сканування коду.
Специфіка JSX розмітки у React вимагає окремих правил оформлення. Атрибути елементів розподіляються по окремих рядках при їх кількості більше трьох, що критично важливо для форм та складних компонентів. Багаторядкові елементи завершуються закриваючим тегом на новому рядку. Компоненти без вкладеного вмісту оформлюються як самозакриваючі теги. Умовні конструкції завжди використовують фігурні дужки, а для умовного рендерингу застосовується патерн раннього повернення, логічний оператор && та тернарний оператор залежно від складності умови.
Документування коду реалізується через систему JSDoc, яка описує сигнатури функцій з типізацією параметрів та значень повернення. Філософія коментування полягає у поясненні причин прийняття рішень, а не опису очевидних операцій. У React екосистемі компоненти рідко потребують JSDoc завдяки самодокументованості через PropTypes або TypeScript, тому документація концентрується на утилітарних функціях та складній бізнес-логіці.

4 ВИСНОВКИ 
У ході роботи було детально вивчено основні положення Google JavaScript Style Guide, що включають конвенції іменування змінних, функцій та компонентів, організацію структури файлів та модулів, правила форматування коду, специфіку роботи з JSX розміткою та принципи документування через JSDoc.
Також було здобуто практичні навички застосування стандарту в контексті React розробки, зокрема правильного структурування компонентів з логічним розміщенням хуків та обробників подій, використання патернів умовного рендерингу, дотримання правил відступів у два пробіли, обов'язкового застосування крапок з комою та організації імпортів за встановленою ієрархією.
Впровадження цих рекомендацій сприяє створенню консистентної кодової бази, покращує читабельність та підтримуваність програмного забезпечення, полегшує процес code review та колективної розробки, а також прискорює адаптацію нових членів команди до проєкту.

5 ВИКОРИСТАНІ ДЖЕРЕЛА 
Google JavaScript Style Guide [Електронний ресурс]. – Режим доступу: https://google.github.io/styleguide/jsguide.html
React Documentation – Best Practices [Електронний ресурс]. – Режим доступу: https://react.dev/learn
ESLint – Pluggable JavaScript Linter [Електронний ресурс]. – Режим доступу: https://eslint.org/

ДОДАТОК А 
Відеозапис 
Відеозапис доповіді: https://youtu.be/fDgMwRTt2mI
Хронологічний опис відеозапису: 
0:00 - Вступ
0:32 - Що таке Google Style Guide
1:06 - Іменування змінних та констант
2:03 - Іменування функцій та методів
3:02 - Структура файлів та імпорти
4:07 - Структура React компонента
5:00 - Форматування та відступи
6:18 - JSX стильові рекомендації
7:27 - Коментарі та документація
8:12 - Обробка помилок та умови
9:11 - Список використаних джерел та підсумки


ДОДАТОК Б 
Слайди презентації
 
Рисунок Б.1 - Титульний слайд

 
Рисунок Б.2 - Зміст презентації

 
Рисунок Б.3 - Що таке Google JavaScript Style Guide?

 
Рисунок Б.4 - Іменування функцій та методів

 
Рисунок Б.5 - Структура файлів та імпорти

 
Рисунок Б.6 - Структура React компонента

 
Рисунок Б.7 - Форматування та відступи

 
Рисунок Б.8 - JSX стильові рекомендації

 
Рисунок Б.9 - Коментарі та документація

 
Рисунок Б.10 - Обробка помилок та умови

 
Рисунок Б.11 - Список Використаних джерел

 
Рисунок Б.12 - Дякую за увагу!


ДОДАТОК В 
Програмний код
В.1 Приклад програмного коду для іменування змінних та констант
GitHub репозиторій: https://github.com/google/styleguide

1  // Змінні та функції - camelCase
2  const userName = 'Іван';
3  let userAge = 25;
4
5  // Константи - UPPER_SNAKE_CASE
6  const MAX_LOGIN_ATTEMPTS = 3;
7  const API_BASE_URL = 'https://api.example.com';
8
9  // React компонент - PascalCase
10 function UserProfile({ name, age }) {
11   return (
12     <div className="profile">
13       <h2>{name}</h2>
14       <p>Вік: {age}</p>
15     </div>
16   );
17 }

В.2 Приклад програмного коду для іменування функцій та методів
GitHub репозиторій: https://github.com/google/styleguide

1  // Звичайні функції - дієслова
2  function calculateTotal(items) {
3    return items.reduce((sum, item) => sum + item.price, 0);
4  }
5
6  // React компонент з обробниками подій
7  function LoginForm() {
8    const [email, setEmail] = useState('');
9    
10   // Обробники подій - префікс handle
11   const handleEmailChange = (event) => {
12     setEmail(event.target.value);
13   };
14   
15   const handleSubmit = (event) => {
16     event.preventDefault();
17     // логіка відправки форми
18   };
19   
20   return (
21     <form onSubmit={handleSubmit}>
22       <input 
23         value={email} 
24         onChange={handleEmailChange} 
25         placeholder="Email"
26       />
27       <button type="submit">Увійти</button>
28     </form>
29   );
30 }

В.3 Приклад програмного коду для структури файлів та імпортів
GitHub репозиторій: https://github.com/google/styleguide

1  // UserDashboard.jsx
2
3  // 1. Зовнішні бібліотеки (React та сторонні пакети)
4  import React, { useState, useEffect } from 'react';
5  import PropTypes from 'prop-types';
6
7  // 2. Внутрішні компоненти проєкту
8  import Header from './Header';
9  import UserCard from './UserCard';
10
11 // 3. Утиліти та константи
12 import { fetchUserData } from '../utils/api';
13 import { DASHBOARD_TITLE } from '../constants';
14
15 // 4. Стилі (завжди в кінці)
16 import './UserDashboard.css';
17
18 function UserDashboard({ userId }) {
19   const [userData, setUserData] = useState(null);
20   
21   useEffect(() => {
22     fetchUserData(userId).then(setUserData);
23   }, [userId]);
24   
25   return (
26     <div className="dashboard">
27       <Header title={DASHBOARD_TITLE} />
28       {userData && <UserCard user={userData} />}
29     </div>
30   );
31 }
32
33 export default UserDashboard;

В.4 Приклад програмного коду для структури React компонента
GitHub репозиторій: https://github.com/google/styleguide

1  function TodoList({ initialTodos }) {
2    // 1. Хуки стану
3    const [todos, setTodos] = useState(initialTodos);
4    const [filter, setFilter] = useState('all');
5    
6    // 2. Хуки ефектів
7    useEffect(() => {
8      localStorage.setItem('todos', JSON.stringify(todos));
9    }, [todos]);
10   
11   // 3. Обробники подій
12   const handleAddTodo = (text) => {
13     const newTodo = {
14       id: Date.now(),
15       text,
16       done: false
17     };
18     setTodos([...todos, newTodo]);
19   };
20   
21   const handleToggleTodo = (id) => {
22     setTodos(todos.map(todo => 
23       todo.id === id ? { ...todo, done: !todo.done } : todo
24     ));
25   };
26   
27   // 4. Допоміжні функції
28   const getFilteredTodos = () => {
29     if (filter === 'active') return todos.filter(t => !t.done);
30     if (filter === 'completed') return todos.filter(t => t.done);
31     return todos;
32   };
33   
34   // 5. Рендер
35   return (
36     <div className="todo-list">
37       {getFilteredTodos().map(todo => (
38         <TodoItem 
39           key={todo.id} 
40           todo={todo} 
41           onToggle={handleToggleTodo} 
42         />
43       ))}
44     </div>
45   );
46 }

В.5 Приклад програмного коду для форматування та відступів
GitHub репозиторій: https://github.com/google/styleguide

1  // Правильно: 2 пробіли, коротке форматування
2  function ProductCard({ product }) {
3    const { name, price, inStock } = product;
4    
5    return (
6      <div className="card">
7        <h3>{name}</h3>
8        <p className="price">{price} грн</p>
9        {inStock ? (
10         <button className="buy-btn">Купити</button>
11       ) : (
12         <span className="out-of-stock">
13           Немає в наявності
14         </span>
15       )}
16     </div>
17   );
18 }
19
20 // Неправильно: 4 пробіли, погане форматування
21 function ProductCard({product}) {
22     return <div><h3>{product.name}</h3><p>
23     {product.price}</p></div>
24 }

В.6 Приклад програмного коду для JSX стильових рекомендацій
GitHub репозиторій: https://github.com/google/styleguide

1  // Правильно: атрибути на окремих рядках
2  function RegistrationForm() {
3    return (
4      <form
5        className="registration-form"
6        onSubmit={handleSubmit}
7        noValidate
8      >
9        <input
10         type="email"
11         name="email"
12         value={email}
13         onChange={handleEmailChange}
14         placeholder="Введіть email"
15         required
16       />
17       <button
18         type="submit"
19         className="btn-primary"
20         disabled={isSubmitting}
21       >
22         Зареєструватися
23       </button>
24     </form>
25   );
26 }
27
28 // Самозакриваючі теги для компонентів без дітей
29 <UserAvatar src={avatarUrl} size="large" />
30 <Loader />
31
32 // Неправильно
33 <input type="email" name="email" value={email} onChange={handleEmailChange} placeholder="Email" required />

В.7 Приклад програмного коду для коментарів та документації
GitHub репозиторій: https://github.com/google/styleguide

1  /**
2   * Форматує ціну для відображення в інтерфейсі
3   * @param {number} price - Ціна в копійках
4   * @param {string} currency - Код валюти (UAH, USD, EUR)
5   * @return {string} Відформатована ціна
6   */
7  function formatPrice(price, currency = 'UAH') {
8    const amount = price / 100;
9    const symbols = { UAH: '₴', USD: '$', EUR: '€' };
10   return `${amount.toFixed(2)} ${symbols[currency]}`;
11 }
12
13 /**
14  * Перевіряє чи є email валідним
15  * @param {string} email - Email адреса для перевірки
16  * @return {boolean} true якщо email валідний
17  */
18 function isValidEmail(email) {
19   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
20   return emailRegex.test(email);
21 }
22
23 // Використання в React компоненті
24 function ProductPrice({ priceInCents }) {
25   return (
26     <span className="price">
27       {formatPrice(priceInCents, 'UAH')}
28     </span>
29   );
30 }

В.8 Приклад програмного коду для обробки помилок та умов
GitHub репозиторій: https://github.com/google/styleguide

1  // Паттерн раннього виходу
2  function UserProfile({ user }) {
3    // Ранній вихід для спрощення логіки
4    if (!user) {
5      return <div>Користувача не знайдено</div>;
6    }
7    
8    if (!user.isVerified) {
9      return <div>Акаунт не підтверджено</div>;
10   }
11   
12   return (
13     <div className="profile">
14       <h2>{user.name}</h2>
15       
16       {/* Умовний рендеринг для простих умов */}
17       {user.isPremium && (
18         <span className="badge">Premium</span>
19       )}
20       
21       {/* Тернарний оператор для if/else */}
22       {user.notifications.length > 0 ? (
23         <NotificationList items={user.notifications} />
24       ) : (
25         <p>Немає нових сповіщень</p>
26       )}
27     </div>
28   );
29 }
30
31 // Неправильно: вкладена логіка
32 function UserProfile({ user }) {
33   return (
34     <div>
35       {user ? (
36         user.isVerified ? (
37           <div>{user.name}</div>
38         ) : (
39           <div>Не підтверджено</div>
40         )
41       ) : (
42         <div>Не знайдено</div>
43       )}
44     </div>
45   );
46 }
